# To make the algorithm efficient, notice that
#   1) b has to be a prime number for n = 0
#   2) since n*n + (1+y)*n + y = (n+1)*(n+y), thus a can't be (b+1)
def main():
    primes = sieve_prime(1000)
    max_count = 0
    for b in primes:
        for a in xrange(-999,1000):
            if a == b + 1:
                continue
            else:
                new_count = N_cont_prime(a,b,primes)
                if new_count > max_count:
                    max_count = new_count
                    A, B = a, b
    print "a is: %d,\nb is: %d,\na*b is: %d,\nmax number of primes generated is: %d." %(A,B,A*B, max_count)

def sieve_prime(N):
    a = range(2,N+1)
    p = 2
    while p <= N:
        # sieve
        if 2 <= N/p:
            for i in xrange(2, N/p+1):
                if a[i*p-2]:
                    a[i*p-2] = 0
            p += 1
        else:
            return [x for x in a if x] 



def N_cont_prime(a,b,primes):
    """ Get number of consecutive prime numbers generated by 
    n*n + a*n + b"""
    def is_prime(n, primes):
        for x in primes:
            if n%x == 0 and n!=x:
                return False
        return True

    n = 1
    while is_prime(n*n + a*n + b, primes):
        n += 1

    return n

if __name__ == '__main__':
    main()
